\documentclass[a4paper, 11pt]{report}

\addtolength{\hoffset}{-1cm}
\addtolength{\textwidth}{2cm}

\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}
\usepackage[T1]{fontenc}

\usepackage{tikz}


\begin{document}

\chapter{Serveur OCaml - Béatrice Carré}

Le serveur a été réalisé en OCaml. Il utilise les modules Thread, Mutex
Unix, Arg (pour parser les options du serveur) et Str (pour les expressions régulières du protocol).
Nous détaillerons par la suite les choix d'implémentation qui ont été faits.

\section{Etablissement du serveur}

L'établissement du serveur a été fait en s'inspirant du chapitre 20 de
\emph{Développement d'Applications avec Objective Caml}.
Comme spécifié dans le sujet du projet, la connexion s'appuie sur un protocole TCP sur le port \emph{port}.
Le serveur a des paramètres par défaut modifiables par option au
moment du lancement :
\begin{itemize}
\item le \emph{timeout} qui vaut 30 secondes par défaut
\item le nombre de joueur \emph{max} pour le lancement de la partie,
  qui vaut 4 par défaut
\item le \emph{port} utilisé valant 2013 par défaut
\item le nom du fichier \emph{dico} valant dico.txt par défaut
\item le nombre \emph{n} de joueur devant dénoncer un dessinateur pour
  qu'il soit considéré comme tricheur, qui vaut 2 par défaut
\end{itemize}
Avant l'établissement du serveur, une fonction parse les arguments
grâce au module \emph{Arg}.

\section{Traitement d'une commande - camllex et camlyacc}

Afin de traiter les commandes reçues, en respectant le protocle, il
était intéressant d'utiliser, les générateurs d'analyseur syntaxique
ocamllex et de parser ocamlyacc.

Après avoir créé des constructeurs de commandes dans le fichier \emph{protocol.ml}, il a
fallu définir la grammaire du parser (dans \emph{parser.mly}) et les
expressions régulières manipulées (dans \emph{lexer.mll}). La grammaire nous indique les 
actions à faire en utilisant le protocole, à partir d'expressions définies.

Ainsi, commande et arguments sont aisément identifiés et manipulés. 
Une fois cela fait, pour traiter une commande reçue, il suffit
de combiner le lexer et le parser, pour
obtenir le type \emph{command} défini dans le protocole. Pour
envoyer une commande, il suffira d'utiliser les constructeurs définis
dans le protocol et de transformer la commande obtenur en chaîne de
caractère, grâce à la fonction string\_of\_command du fichier protocol.ml  

Le traitement des commandes se reposera par la suite sur les
ce type somme défini et les fonctions associées à sa manipulation.

\section{Connexion}

La phase de connexion est séparée de la boucle principale de jeu afin
d'identifier les conditions de connexion (joueur ou spectateur) et
lancer le traitement adéquat. Si le pseudo reçu est déjà utilisé
(joueur présent), alors un nouveau pseudo est généré en rajoutant un
entier entre parenthèse à la fin. Au bout du max-ième joueur se
connectant, la partie est lancée, dans un autre thread.

\section{Structures de données}

Lors de la connexion, la structure représentant le \emph{joueur} est alors initialisée. Elle comprend :
\begin{itemize}
\item son nom
\item la socket grâce à laquelle il communique avec le serveur
\item son thread
\item son role dans la partie, qui peut être 'undefined', 'drawer' ou 'guesser'
\item un booléen pour préciser s'il a déjà dessiné dans la partie
\item un booléen indiquant s'il a trouvé le mot à ce 'round'
\item son score du 'round'
\end{itemize}

Le role du joueur est représenté par un type somme qui nous permettra
aisément de vérifier si une commande est licite à un moment de la partie
donné selon son rôle.

Les joueurs sont stockés dans une liste (de taille maximale max donc),
ce qui permet d'utiliser les nombreuses fonctions du module List. 
Les spectateurs, stockés dans une autre liste, ne sont représentés que par leur socket.

Ces listes sont dans une structure représentant l'état de la
partie du \emph{server} :
\begin{itemize}
\item la liste des joueurs connectés
\item la liste des spectateurs représentés par leur socket
\item une liste des mots déjà sortis lors du round
\item un booléen indiquant si la partie est en cours
\item la liste des commandes envoyées depuis le début de la partie
\end{itemize}

Le type état est représenté par un type somme (Alive ou Dead). Il peut paraître ici assez inutile, mais il a été implémenté initialement dans l'objectif de réaliser d'extensions qui n'ont finalement jamais vu le jour (réparer un bateau, lancer une épidémie, ...).

Le \emph{round} est représenté par une structure comprenant 
\begin{itemize}
\item un timer
\item le joueur dessinateur
\item le nom du premier à avoir trouvé
\item le mot à trouver
\item le compteur du nombre de joueur ayant trouvé le mot
\item le nombre de joueur ayant dénoncé le dessinateur
\item la couleur courante (par défaut noir)
\item la taille courante (par défaut 0)
\end{itemize}

Et enfin, le \emph{timer}, qui a été implémenté en objet, pour pouvoir le 
manipuler facilement avec un accès simple aux méthodes.
Ce timer est créé avec un temps initial (le temps de la partie) et une
fonction de callback (ici, next\_round). Il comprend :
\begin{itemize}
\item le temps total de la partie
\item un booléen indiquant s'il est en train de tourner
\item des mutexs sur ces variables
\item une méthode pour lancer le timer
\item une méthode qui le réinitialise
\item une méthode d'accès et de modification du temps
\item une méthode qui arrête le timer.
\end{itemize}

\section{Extensions réalisées}

\subsection{Discussion instantanée}

Cette extension a été plutôt aisée à implémenter, dès que le serveur reçoit la commande ``TALK'' correctement formée, il renvoie à tout le monde (clients et spectateurs) le message passé en argument précédé de son émetteur. Le split de la commande permet de respecter le protocole.

\subsection{Spectateurs}

Pour cette extension, il a fallu ajouter un mécanisme qui stocke les commandes voulues et les envoie aux spectateurs déjà présents. Dès qu'un spectateur se connecte, il reçoit alors la liste des commandes stockées. Grâce au split des commandes, il a suffi de changer le nom de la commande (``PUTSHIP'' en ``PLAYERSHIP'', ...) qui correspond au premier élément de la liste résultante.

\section{Architecture}

L'architecture n'est pas forcément très rigoureuse car elle n'a pas
été développée dans un esprit de réutilisabilité. Lors de la connexion
d'une nouvelle socket, un thread exécutant \emph{init\_new\_client}
est lancé. Cette fonction lance la phase de connexion évoquée plus
haut, et selon le résultat exécute \emph{start\_player} ou
\emph{start\_spectator}. La deuxième fonction se contente de récupérer 
les commandes déjà effectuées et d'ajouter sa socket à la structure du
server. La première effectue une boucle qui match les commandes reçues
afin de lancer le traitement adapté selon son rôle.

Ci-suit une liste des modules :
\begin{itemize}
\item RegExp : stocke les expressions régulières, mais elles ont été beaucoup moins utilisées que pensé initialement
\item Utils : toutes les fonctions utilitaires, ne se rapportant pas spécifiquement à un autre module
\item Next : gère le correct enchaînement des ``YOURTURN''
\item Register : gère les comptes utilisateurs
\item Stop : gère les déconnexions
\item Connexion : cf plus haut
\item Placement : gère la phase de placement des bateaux (et oui, quel nom adéquat !)
\item End\_of\_game : gère la fin de partie (plus ou moins bien, des tests exhaustifs n'ont pas été effectués)
\item Game : gère les phases d'actions
\end{itemize}

\section{Choix d'implémentation}
L'énoncé étant parfois libre de choix, voici les décisions prises les
concernant :
 \begin{itemize}
\item fin partie
\item pass
\item pas de connexions joueurs en cours de partie
\item spectator : pas chat
\end{itemize}

Bon jeu !

\end{document}
